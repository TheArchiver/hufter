{"algo":"#include <iostream>\n#include <math.h>\n#include <stdlib.h>\n#include <fstream>\n#include <cstdlib>\n#include <vector>\n#include <sstream>\n#include <iomanip>\nusing namespace std;\n\nstruct data{\n  string time;\n  double price;\n};\nvector<vector<data>> algo_test(vector<data>& data_set){\n    vector<vector<data>> signals;\n    vector<data> buy; vector<data> sell;\n    int end = data_set.size() - 1;//something weird was happening when using data_set.size() -1 in if()\n    for(int i=0; i<data_set.size(); i++){\n\n      if( (i < end ) && (data_set[i].price < data_set[i+1].price) ){\n        buy.push_back(data_set[i]);\n        sell.push_back(data_set[i+1]);\n      }\n\n    }\n\n    signals.push_back(buy);\n    signals.push_back(sell);\n    return signals;\n}\n\n//helper functions used for entropy_algo:\nvector<data> slide_time_window( int& index, vector<data>& data_set, vector<data>& window)\n{\n  vector<data> new_window;\n  for(int i=1; i< window.size(); i++){\n    new_window.push_back(window[i]);\n  }\n  index += 1;\n  new_window.push_back(data_set[index]);\n  return new_window;\n}\n\nvoid initalize_window(int size, vector<data>& window, vector<data>& data_set){\n  for(int i = 0; i < size; i++){\n    window.push_back(data_set[i]);\n  }\n}\n\ndouble average(vector<data>& window){\n  double sum = 0;\n  double total = window.size()*1.0;\n  for(int i=0; i < window.size(); i++){\n    sum += window[i].price;\n  }\n  sum = sum/total;\n  return sum;\n}\n\n//shanon's entropy of information (applied in a binary system)\ndouble entropy(vector<data>& window, int& pCount, int& nCount){\n  //int pCount, nCount;\n  double pU,pN;\n  pCount = nCount = 0;\n  double entropy;\n  for(int i = 0; i < window.size()-1; i++){\n    if(window[i].price < window[i+1].price){\n      pCount += 1;\n    }\n    if(window[i].price > window[i+1].price){\n      nCount += 1;\n    }\n    pU = pCount*1.0 / window.size()*1.0;\n    pN = nCount*1.0 / window.size()*1.0;\n  }\n  entropy = -1*pU*log(pU) + -1*pN*log(pN);\n  return entropy;\n}\n\ndouble mapped_entropy(double& entropy){\n  double entropy_max = 0.301029995664;\n  return (1-pow(entropy/entropy_max,2) );\n}\n//helper function END\n\nvector<vector<data>> entropy_algo(vector<data>& data_set){\n    vector<vector<data>> signals;\n    vector<data> buy; vector<data> sell;\n    vector<data> window;\n    int index = 0;\n    int pCount, nCount;\n    double ent,mapped_ent;\n    initalize_window(14, window, data_set);\n\n    while( index < data_set.size() ){\n      ent = entropy(window, pCount, nCount);\n      mapped_ent = mapped_entropy(ent);\n      //0.7 is an arbitrary constant, and in general will be a paramter to be varierd and optimized\n      //mapped_entropy uses powers of 2 (symetric with undervalued and overvalued stock state), and thus we must make sure nCount > pCount is true\n      if( mapped_ent > 0.7 && nCount > pCount){\n        buy.push_back(data_set[index]);\n      }\n      int last_index = sell.size() -1;\n      if(last_index > -1){\n        if( data_set[index].price > buy[last_index].price){\n          sell.push_back(data_set[index]);\n        }\n      }\n\n      slide_time_window(index, data_set, window);\n    }\n\n    signals.push_back(buy);\n    signals.push_back(sell);\n    return signals;\n}\n","startDate":"2015-03-04","endDate":"2015-12-29","symbols":"[\"AMD\"]","lang":"cpp"}